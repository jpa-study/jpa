# 01. JPA 소개

## 목차

1. 서론
2. SQL 을 직접 다룰 시 발생하는 문제
3. 패러다임 불일치
4. JPA란?
5. 정리



<br>



## 01. 서론

RDB 는 가장 널리 쓰이면서도 신뢰도가 높은 데이터 저장소이다. 따라서 Java 등을 이용하여 개발 시 상당수가 RDB 를 사용하여 데이터를 보관하고 있다.

그러나 Java 등의 객체지향과 RDB 와는 컨셉이나 패러다임이 상이하기 때문에 직접적으로 연결할 수가 없었다. 따라서 어플리케이션 단과 DB 사이에서 객체를 SQL 로 매핑해서 변환해 주는 등의 부차적인 비용이 많이 소요됬다.

따라서 이런 문제를 해결하기 위해 Hibernate 와 같은 ORM 이 등장하였고, 여러 ORM 을 하나로 묶에 쉽게 이용할 수 있게 도와주는 표준 API 가 등장했는데, 이것이 바로 JPA 이다.

JPA 는 기존 개발자가 반복적으로 해왔던 SQL 매핑 작업을 알아서 변환해주며, 기타 human error 등이 발생할 수 있는 부분까지 알아서 처리해주게 되었다.

이 덕분에 개발자는 로직에 집중할 수 있게 되었고, 객체를 이용하여 직관적으로 데이터를 다룰 수 있게 되었다.

아래에선 JPA 를 사용하기 전에 어떠한 문제들이 있었는지 살펴보고, 이를 도입함으로써 얻을 수 있는 이익을 알아보겠다.



<br>



## 01. SQL 을 직접 다룰 시 발생하는 문제

일반적으로 Java 로 작성한 코드에선 JDBC 를 이용해 SQL 작성해 DB 와 통신한다. 그러나 이런 방식은 반복이 너무 많다는 점과 SQL 에 의존적인 개발을 하게 된다는 한계가 있다.



<br>



### 계속되는 반복

쇼핑몰의 회원 정보를 다루는 예시를 생각해보자.

회원 정보를 가져오는 기능을 추가하기 위해선 아래와 같은 절차를 거치게 된다.

1. DTO & DAO 객체를 생성한다

   * Member.java, MemberDAO.java

2. 회원 조회 쿼리를 작성한다 

   ````SQL
   SELECT member_id, name
   FROM member
   WHERE member_id = ?;
   ````

3. JDBC 로 SQL 을 실행한다

   ````java
   ResultSet rs = stmt.executeQuery(sql);
   ````

4. 조회 결과를 Member 객체로 매핑한다.

   ````java
   String memberId = rs.getString("member_id");
   ...
   Member member = new Member();
   member.setMemberId(memberId);
   ...
   ````



<br>



다음으론 회원 등록 기능을 만든다고 생각해보자.

1. 회원 등록 쿼리를 작성한다.
2. 회원 객체 값을 꺼내 SQL 에 전달한다.
3. JDBC 로 SQL 을 실행한다.



<br>



겨우 2개의 기능만 살펴봤을 뿐인데 벌써 **많은 반복 작업**이 발생했다는 것을 알 수 있다. 그리고 반복뿐만 아니라 **SQL 을 매번 작성해야 하는 것 자체도 큰 부담**이 된다.

SQL을 작성하는 것 대신 Java 의 컬렉션에 저장할 수 있다면 `list.add(member);` 처럼 매우 간단히 처리할 수 있으나, 안타깝게도 DB 는 객체구조가 아닌 데이터 중심 구조이기 때문에 객체를 DB 에 직접 저장하거나 조회할 수는 없다.

따라서 결국은 개발자가 직접 객체지향 코드와 DB 사이에서 SQL 과 JDBC 로 변환 작업을 해 줘야 한다.



<br>



### SQL 에 의존적인 개발

위 예시에서 갑자기 회원정보에 팀 정보도 같이 저장해달라는 요구사항이 추가됬다고 해보자.

요구사항을 반영하기 위해선 아래와 같은 순서로 작업을 진행할 것이다.



<br>



전화번호를 포함해 저장하는 로직으로 변경

1. Member 객체에 Team 객체 필드 추가
2. 팀 정보도 DB 에 저장할 수 있도록 INSERT 쿼리 변경
3. 팀 값을 SQL 로 매핑하는 코드 추가



전화번호를 포함하여 조회하는 로직으로 변경

1. SELECT 쿼리 수정
2. 팀 조회 결과를 Member 객체에 추가로 매핑



<br>



여기까지 수정을 하고 기존 MemberDAO 에 새로 작성된 findWithTeam() 메서드를 통해 멤버와 그 팀 정보를 가져왔는데 팀 정보가 계속 null 이 발생했다.

알고보니 findWithTeam() 메서드에선 기존에 사용하던 find() 를 그대로 사용하고 있었고, 여기에 Team 정보를 JOIN 하여 가져오게 수정한 뒤에야 정상적으로 동작하였다.



<br>



이런 단적인 예시에서 알 수 있듯이 무언가 새로운 것이 추가되면 **개발자가 로직보다는 SQL 을 매번 직접 확인해가면서 작업**할 수 밖에 없고, 결국 비즈니스 요구사항이 모델링 된 객체인 **Entity 를 신뢰할 수 없다는 문제**가 발생한다.

이는 결국 **물리적으로 SQL 과 JDBC 를 데이터 접근 계층에 숨기는데는 성공**했으나, **논리적으로는 Entity 와 아주 강한 연관관계**를 지니게 되어 버렸기 때문에, **개발자는 SQL 을 일일히 보며 작업하는 SQL 에 의존적인 개발**을 할 수 밖에 없게 되었다.



<br>



## 02. 패러다임의 불일치







